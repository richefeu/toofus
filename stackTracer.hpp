// Copyright (C) <vincent.richefeu@3sr-grenoble.fr>
//
// This file is part of TOOFUS (TOols OFten USued)
//
// It can not be copied and/or distributed without the express
// permission of the authors.
// It is coded for academic purposes.
//
// Note
// Without a license, the code is copyrighted by default.
// People can read the code, but they have no legal right to use it.
// To use the code, you must contact the author directly and ask permission.

#ifndef STACKTRACER_HPP
#define STACKTRACER_HPP

#include <csignal>
#include <iostream>
#include <sstream>
#include <string>

#if !defined(__WIN32) && !defined(__WIN64) && !defined(__WIN32__)
#include <execinfo.h>
#endif
#include <cxxabi.h>

class StackTracer {
public:
  /// Given a mangled C++ name, demangle it and return the demangled name.
  /// If demangling fails, returned mangled name with some parens.
  /// For example, given "foo(int, double)" might return "foo(int, double)"
  /// or "_ZN3fooEid" depending on the platform.
  static std::string DeMangleCXXName(const std::string &stackString) {
    const size_t kMaxNameLen = 4096;
    char function[kMaxNameLen];
    size_t start = stackString.find('(');
    size_t end = stackString.find('+');
    if (std::string::npos == start || std::string::npos == end)
      return stackString;
    int status;
    ++start; // puts us pass the '('
    size_t n = end - start;
    size_t len;
    std::string mangled = stackString.substr(start, n);
    abi::__cxa_demangle(mangled.c_str(), function, &len, &status);
    if (0 == status) // demanging successful
      return std::string(function);
    // If demangling fails, returned mangled name with some parens
    return mangled + "()";
  }

  /// Generate a stack trace of the current program.  The output is a string
  /// with each line of the form "   <mangled-name>(<offset>)" where
  /// <mangled-name> is the demangled name of the function, and <offset> is
  /// the offset of the function.  We skip the first entry (which is the
  /// StackTrace() function itself).
  static std::string StackTrace() {
    std::stringstream result;

#if !defined(__WIN32) && !defined(__WIN64) && !defined(__WIN32__)
    result << "Stack Trace:" << std::endl;
    const size_t kMaxDepth = 100;
    void *stackAddrs[kMaxDepth];
    int stackDepth;
    char **stackStrings;
    stackDepth = backtrace(stackAddrs, kMaxDepth);
    stackStrings = backtrace_symbols(stackAddrs, stackDepth);
    for (int i = 1; i < stackDepth; ++i) {
      result << "   " << DeMangleCXXName(stackStrings[i]) << std::endl;
    }
    std::free(stackStrings);
#endif

    return result.str();
  }

  /// A default signal handler for common signals that kills the program.
  ///
  /// It prints a message to cerr with the signal received, and if the signal
  /// is not SIGINT, it prints the stack trace of the current program.
  ///
  /// The supported signals are:
  /// - SIGABRT: Abnormal termination, such as is initiated by the abort
  ///            function.
  /// - SIGFPE:  Erroneous arithmetic operation, such as zero divide or an
  ///            operation resulting in overflow (not necessarily with a
  ///            floating-point operation).
  /// - SIGILL:  Invalid function image, such as an illegal instruction.
  ///            This is generally due to a corruption in the code or to an
  ///            attempt to execute data.
  /// - SIGINT:  Interactive attention signal. Generally generated by the
  ///            application user.
  /// - SIGSEGV: Invalid access to storage: When a program tries to read or
  ///            write outside the memory it is allocated for it.
  /// - SIGTERM: Termination request sent to program.
  static void defaultSigHandler(int sig) {
    std::cerr << std::endl << "The Simulation received the following signal:" << std::endl;

    if (sig == SIGABRT) {
      std::cerr << "(\033[31mAbort\033[0m) Abnormal termination, such as is initiated by the abort function."
                << std::endl;
    } else if (sig == SIGFPE) {
      std::cerr << "(\033[31mFloating-Point Exception\033[0m) Erroneous arithmetic operation, such as zero divide or "
                   "an operation \nresulting in overflow (not necessarily with a floating-point operation)."
                << std::endl;
    } else if (sig == SIGILL) {
      std::cerr << "(\033[31mIllegal Instruction\033[0m) Invalid function image, such as an illegal instruction. "
                   "\nThis is generally due to a corruption in the code or to an attempt to execute data."
                << std::endl;
    } else if (sig == SIGINT) {
      std::cerr
          << "(\033[31mInterrupt\033[0m) Interactive attention signal. Generally generated by the application user."
          << std::endl;
    } else if (sig == SIGSEGV) {
      std::cerr << "(\033[31mSegmentation Violation\033[0m) Invalid access to storage: \nWhen a program tries to read "
                   "or write outside the memory it is allocated for it."
                << std::endl;
    } else if (sig == SIGTERM) {
      std::cerr << "(\033[31mTerminate\033[0m) Termination request sent to program." << std::endl;
    }

    if (sig != SIGINT) {
      std::cerr << StackTrace() << std::endl;
    }
    exit(EXIT_SUCCESS);
  }

  /// Initializes the default signal handlers for the common signals SIGABRT, SIGTERM, SIGINT, and SIGSEGV.
  ///
  /// This function should be called once at the beginning of the main program.
  static void initSignals() {
    signal(SIGABRT, &defaultSigHandler); // Signal Abort
    signal(SIGTERM, &defaultSigHandler); // Signal Terminate
    signal(SIGINT, &defaultSigHandler);  // Signal Interupt (ctrl-c)
    signal(SIGSEGV, &defaultSigHandler); // Signal Segmentation Fault
  }

  /// Initializes the default signal handlers for the common signals SIGABRT, SIGTERM, SIGINT, and SIGSEGV.
  ///
  /// This function takes a user-defined signal handler function that is called
  /// when a signal is received. If the function is null, the default signal
  /// handlers are installed which print a message to cerr with the signal
  /// received and the current stack trace, and then exit with success.
  static void initSignals(void (*Handlerfunc)(int)) {
    signal(SIGABRT, Handlerfunc); // Signal Abort
    signal(SIGTERM, Handlerfunc); // Signal Terminate
    signal(SIGINT, Handlerfunc);  // Signal Interupt (ctrl-c)
    signal(SIGSEGV, Handlerfunc); // Signal Segmentation Fault
  }
};

#endif /* end of include guard: STACKTRACER_HPP */
